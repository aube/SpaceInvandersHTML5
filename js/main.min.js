'use strict';

/*Настройки игры
Значение некоторых параметров пересчитываются в зависимости от типа данных:
- Integer (кол-во пикселей),
- Float (в процентах от ширины для X и высоты для Y экрана)
- Array {x:[min,max],y:[min,max]} - rand(min,max)
при этом min и max так же могут быть Integer и Float
*/

var Settings = Object.create(null);

//Player
Settings.player = {
	width: .21
	,height: .05
	,power: 5
	,speed: {x:0.7, y:0.7}
	,marginBottom: .01
	,sprite: {width:39, height:25, top:0, len:1}
}

//Boss
Settings.boss = {
	width: .4
	,height: .08
	,power: 20
	,sprite: {width:252, height:135, top:115, len:1}
	,color: "red"
	,wave: {x:0.2, y:0.7}
	,speed: {x:50, y:140}
}

//Bullet
Settings.bullet = {
	width: 2 //px
	,height: 7 //px
	,power: 1
	,speed: {x:0, y:1.6}
	,color: "yellow"
	,sound: 'sounds/laser.mp3'
}

//Star
Settings.star = {
	width: 1 //px
	,height: 1 //px
	,speed: {x:10, y: [0.1, 4.1]}
	,color: "white"
	,limit: 50
}


//Armada - cетка для объектов enemy
Settings.armada = {
	inrow: 7
	,rows: 3
	,width: .8
	,height: .2
	,marginTop: .2
}

//Enemies
//если заполнен параметр wave и скорость объектов
//различается (при указании min и max), объекты ломают строй
//и начинают перемещаться хаотично
Settings.enemy = {
	horisontalMargin: .4
	,power: 1
	,verticalMargin: .6
	,wave: {x:0.4, y:1.2}
	,speed: {x:30, y:40}
	,sprite: {width:38, height:28, top:78, len:1}
}

//Explosions
Settings.explosion = {
	speed: {x:0,y:0}
	,sprite: {width:512/13, height:38, top:32, len:12}
	,sound: 'sounds/boom2.mp3'
}





//прототип для всех объектов в игре

var Entity = {
	
	/*
	 * Дополнительные параметры поведения объектов
	 * 
	destroyOnOutOfScreen - уничтожение объекта при выходе за границу экрана (true/false)
	cantOutOfScreen - запрет выхода за пределы экрана (true/false)
	destroyOnEndAnimation - уничтожение объекта по завершении анимации (true/false)
	targets - уничтожение при столкновении (тип объекта),
	*/
	
	destroyOnOutOfScreen:false,
	cantOutOfScreen:false,
	destroyOnEndAnimation:false,
	targets:false,
	
	
	//пересчет координат,
	//вызов методов для контроля столкновений и выхода за границу экрана
	update:function(dt)
	{
		
		if (!this.checkOutOfScreen())
			return false;
		
		if (!this.checkCollision())
			return false;
		
		
		if (this.moveto.x !== false)
		{
			if (this.moveto.x == this.pos.x)
				this.moveto.x = false;
			else if (this.moveto.x < this.pos.x)
				this.pos.x -= Math.min(this.speed.x * dt, this.pos.x - this.moveto.x);
			else
				this.pos.x += Math.min(this.speed.x * dt, this.moveto.x - this.pos.x);
		}
		
		if (this.moveto.y !== false)
		{
			if (this.moveto.y == this.pos.y)
				this.moveto.y = false;
			else if (this.moveto.y < this.pos.y)
				this.pos.y -= Math.min(this.speed.y * dt, this.pos.y - this.moveto.y);
			else
				this.pos.y += Math.min(this.speed.y * dt, this.moveto.y - this.pos.y);
		}
		
		
		if (typeof this.wave == 'object')
			this.waveCalculate();
		
		if (typeof this.sprite == 'object')
		{
			if (this.sprite.len > 1)
				this.frame++;
			
			if (this.frame >= this.sprite.len)
				if (this.destroyOnEndAnimation)
					return false;
				else
					this.frame = 0;
			
		}
		
		this.draw();
		return true;
	}
	
	//рассчет волнообразного движения объекта (применяется в enemy)
	,waveCalculate: function()
	{
		
		var offsetX = (Math.round((Math.random()) * 10) % 2 == 0 ? -1 : 1);
		var offsetY = (Math.round((Math.random()) * 10) % 2 == 0 ? -1 : 1);
		
		
		if (this.wave.x && this.moveto.x === false)
			this.moveto.x = offsetX * this.wave.x + this.pos0.x;
		
		if (this.wave.y && this.moveto.y === false)
			this.moveto.y = offsetY * this.wave.y + this.pos0.y;
		
	}
	
	//проверка столкновения с указанным в настройках типом объекта
	,checkCollision: function(targetName)
	{
		targetName = targetName || this.targets;

		if (targetName)
		{
			if (targetName instanceof Array) {
				var n = 0;
				var result = true;
				while(targetName[n])
					result *= this.checkCollision(targetName[n++]);
				return result;
			}
			var targets = Game.Objects[targetName];
			if (targets && targets.length)
				for(var n=0; n < targets.length; n++)
				{
					if (!(this.pos.x+this.width <= targets[n].pos.x
						|| this.pos.x > targets[n].pos.x+targets[n].width
						|| this.pos.y+this.height <= targets[n].pos.y
						|| this.pos.y > targets[n].pos.y+targets[n].height))
					{
						if (targets[n].power <= this.power) {
							targets[n].onDestroy();
							targets.splice(n,1);
						} else {
							targets[n].power -= this.power;
						}
						return false;
					}
				}
		}
		
		return true;
	}
	
	
	//столкновение
	//создание взрыва
	,onDestroy: function()
	{
		Game.registerObject(new Explosion(this.pos.x,this.pos.y, this.width,this.height));
		
	}
	
	//проверка выхода за границы экрана
	//уничтожение объекта "star" или запрет выхода "player"
	,checkOutOfScreen: function()
	{
		if (this.destroyOnOutOfScreen)
		{
			if (this.pos.x > canvas.width
				|| this.pos.x + this.width < 0
				|| this.pos.y > canvas.height
				|| this.pos.y + this.height < 0)
				return false;
		}
		
		if (this.cantOutOfScreen)
		{
			if (this.pos.x + this.width > canvas.width)
				this.pos.x = canvas.width - this.width;
			
			if (this.pos.x < 0 )
				this.pos.x = 0;
			
			if (this.pos.y + this.height > canvas.height)
				this.pos.y = canvas.height - this.width;
			
			if (this.pos.y < 0)
				this.pos.y = 0;
			
		}
		return true;
	}
	
	//отрисовка объекта
	//drawImage если указан спрайт
	//fillRect в остальных случаях
	,draw: function(){
		ctx.save();
		
		if (typeof this.sprite == 'object')
		{
			ctx.drawImage(spritesImage,
				this.sprite.width * this.frame,
				this.sprite.top,
				this.sprite.width, this.sprite.height,
				this.pos.x, this.pos.y, this.width, this.height);
		}
		else
		{
			ctx.fillStyle = this.color;
			ctx.fillRect(this.pos.x, this.pos.y, this.width, this.height);
		}
		ctx.restore();
	}
	
	//получение числовых параметров из настроек
	,getXY: function(paramName){
		
		var x, y;
		var param = Settings[this.type][paramName];
		
		function getX(x)
		{
			return (''+x).indexOf('.') < 0 ? +x : canvas.width * x;
		}
		
		function getY(y)
		{
			return (''+y).indexOf('.') < 0 ? +y : canvas.height * y;
		}
		
		if (typeof param.x === 'object')
			x = Math.floor((Math.random() * getX(param.x[1])) + getX(param.x[0]));
		else
			x = getX(param.x);
		
		if (typeof param.y === 'object')
			y = Math.floor((Math.random() * getY(param.y[1])) + getY(param.y[0]));
		else
			y = getY(param.y);
		
		return {
			x:x,
			y:y
		}
		
	}
	
	
}




var SpaceInvandersHTML5 = function(width, height)
{
	var self = this;
		
	this.level = 0;
	this.gameOver = false;
	
	//loop parameters
	var lastTime = Date.now();
	var now = Date.now();
	var dt = (now - lastTime) / 1000.0;
	
	//fps
	var lastFpsUpdateTime = Date.now();
	var fpsEl = document.getElementById('fps');
	var fps = 0;
	
	//Коллекция для объектов {star:[],enemy:[],...}
	this.Objects = Object.create(null);


	//проверка параметров игры
	this.gameStates = function()
	{
		
		if (now - lastFpsUpdateTime > 1000)
		{
			lastFpsUpdateTime = now;
			fpsEl.innerHTML = fps.toFixed(0) + 'fps';
		}
		
		//all enemies destroed, new level begin
		if (self.Objects['enemy'] && self.Objects['enemy'].length == 0 &&
			self.Objects['boss'] && self.Objects['boss'].length == 0)
		{
			self.startNewLevel();
		}
		
		//player destroed, game over
		if (self.Objects['player'].length == 0)
		{
			self.gameOver = true;
			self.onGameOver();
		}
		
	}
	
	
	//начало игры и переход на следующий уровень
	this.startNewLevel = function()
	{
		self.level++;
		
		Settings.enemy.wave={x:0.1,y:0.2};
		Settings.enemy.speed={x:0.05,y:0.05};
		
			self.registerObject(new Boss());
			Settings.enemy.speed = {x:[0.01,0.4],y:[0.01,0.4]};
			self.generateEnemies();
		if (self.level%2 == 0)
		{
		}
		else if (self.level%3 == 0)
		{
			Settings.enemy.speed = {x:[0.01,0.4],y:[0.01,0.4]};
			Settings.enemy.wave = {x:0.3,y:0.5};
			self.generateEnemies();
		}
		
		var el = document.getElementById('level');
		el.innerHTML = 'level '+self.level;
	}
	
	
	//отображение надписи Game Over
	this.onGameOver = function()
	{
		var el = document.getElementById('gameOver');
		el.style.display = 'block';
		self.Objects.player = [];
	}
	
	
	//обновление координат объектов
	this.update = function(dt)
	{

		ctx.fillRect(0, 0, canvas.width, canvas.height);
		
		for (var type in self.Objects)
		{
			var entType = self.Objects[type];
			for (var n = 0; n < entType.length; n++)
			{
				if (!entType[n].update(dt))
				{
					entType.splice(n--,1);
				}
			}
		}

		this.generateStars();
		
	}
	
	
	//начало игры, установка основных параметров
	//создание корабля игрока
	//запуск цикла
	this.start = function()
	{
		self.Objects = Object.create(null);
		self.gameOver = false;
		self.pause = false;
		self.level = 0;
		
		document.getElementById('gameOver').style.display = 'none';
		
		this.generateStars();
		
		//create player ship
		self.registerObject(new Player());
		
		self.startNewLevel();
		
		self.loop();
		//debugger;
	}
	
	
	//создание вражеских кораблей по координатам,
	//указанным в сетке координат Settings.armada
	this.generateEnemies = function()
	{
		for (var r = 0; r < Settings.armada.rows; r++)
		{
			for (var e = 0; e < Settings.armada.inrow; e++)
			{
				var x = Settings.armada.cellwidth * e + Settings.armada.pos.x + Settings.enemy.margin.x;
				var y = Settings.armada.cellheight * r + Settings.armada.pos.y + Settings.enemy.margin.y;
				self.registerObject(new Enemy(x,y));
			}
		}
	}

	//звёзды создаются рандомно по оси Х
	//и летят по оси Y с разной скоростью
	this.generateStars = function()
	{
		if (!self.Objects.star)
			self.Objects.star = [];
		while (self.Objects.star.length < Settings.star.limit)
			self.registerObject(new Star());
	}
	
	
	//инициализация, дополнительный рассчет параметров
	//загрузка очереди звуков
	//привязка событий
	this.init = function()
	{
		//player
		Settings.player.width = Math.floor(canvas.width * Settings.player.width);
		Settings.player.height = Math.floor(canvas.height * Settings.player.height);
		Settings.player.width = (Settings.player.sprite.width / Settings.player.sprite.height) * Settings.player.height;

		//boss
		Settings.boss.width = Math.floor(canvas.width * Settings.boss.width);
		Settings.boss.height = Math.floor(canvas.height * Settings.boss.height);
		Settings.boss.width = (Settings.boss.sprite.width / Settings.boss.sprite.height) * Settings.boss.height;

		//armada cells
		Settings.armada.cellwidth = Math.floor(canvas.width * Settings.armada.width / Settings.armada.inrow);
		Settings.armada.cellheight = Math.floor(canvas.height * Settings.armada.height / Settings.armada.rows);
		Settings.armada.pos = {x:canvas.width * (1-Settings.armada.width) / 2, y:canvas.height * Settings.armada.marginTop};

		//enemies
		Settings.enemy.margin = {x:Settings.armada.cellwidth * Settings.enemy.horisontalMargin / 2, y:Settings.armada.cellheight * Settings.enemy.verticalMargin / 2};
		Settings.enemy.width = Math.floor(Settings.armada.cellwidth - Settings.enemy.margin.x * 2);
		Settings.enemy.height = Math.floor(Settings.armada.cellheight - Settings.enemy.margin.y * 2);
		//Settings.enemy.width = (Settings.enemy.sprite.width / Settings.enemy.sprite.height) * Settings.enemy.height;
		
		//sounds bind
		for (var n in Settings)
		{
			if (Settings[n].sound)
			{
				Settings[n].sound = new SoundPool(Settings[n].sound);
			}
		}
		
		
		//actions
		document.querySelector('#gameOver > a').addEventListener("click", function(event){
			self.start();
			event.preventDefault();
		});
		
		document.addEventListener("click", function(event){
			
			if (Game.gameOver) return;
			if (event.target != canvas) return;
			
			var player = self.Objects.player[0];
			
			player.moveto.x = event.clientX - player.width/2;
			player.moveto.y = event.clientY - player.height/2;
			self.registerObject(new Bullet(player.pos.x + player.width/2 , player.pos.y, ['enemy', 'boss']));
		});
		

		//poehali!
		self.start();
		
	}

	//основной цикл
	this.loop = function()
	{
		now = Date.now();
		dt = (now - lastTime) / 1000.0;
		fps = 1000 / (now - lastTime);
		lastTime = now;
		
		self.gameStates();
		self.update(dt);
		
		requestAnimationFrame(self.loop);
	}

	//добавление объекта в коллекцию
	this.registerObject = function(Entity)
	{
		
		if (undefined == this.Objects[Entity.type])
			self.Objects[Entity.type] = [];
		
		self.Objects[Entity.type].push(Entity);
		
		if (typeof Settings[Entity.type].sound == 'object')
			Settings[Entity.type].sound.play();
		
	}

};






function SoundPool(filename, size)
{
	var size = size || 10;
	var sounds = [];
	var current = 0;

	this.init = function(type) {
		for (var i = 0; i < size; i++)
		{
			var sound = new Audio(filename);
			sound.volume = .3;
			sound.load();
			sounds.push(sound);
		}
	}();

	this.play = function() {
		sounds[current].play();
		current = (current + 1) % size;
	};
}


function Boss()
{
	var x = canvas.width/2;
	var y = canvas.height/2;

	this.destroyOnOutOfScreen = false;
	
	this.type = 'boss';
	this.targets = 'player';
	this.pos0 = {x: 0, y: 0};
	this.pos0 = {x: x, y: y};
	this.pos = {x: x, y: y};
	this.moveto = {x: x, y: y};
	//this.pos = {x:10, y:10};
	
	this.speed = this.getXY('speed');
	this.wave = this.getXY('wave');
	
	
	//this.wave = {
	//	x:Settings.armada.width * this.wave.x * canvas.width,
	//	y:Settings.armada.height * this.wave.y * canvas.height
	//}
	
	//console.log(this.wave);
	
	this.width = Settings.boss.width;
	this.height = Settings.boss.height;

	//this.color = Settings.boss.color;
	this.sprite = Settings.boss.sprite;
	this.frame = 0;
	this.power = Settings.boss.power;

	this.draw();
	
	// this.getPosition = function()
	// {
		
	// }
	
}


Boss.prototype = Entity;


function Bullet(x, y, targets)
{
	
	this.type = 'bullet';
	
	this.destroyOnOutOfScreen = true;
	this.targets = targets;
	
	
	this.width = Settings.bullet.width;
	this.height = Settings.bullet.height;
	this.pos = {x:x, y:y};
	
	
	this.moveto = {
		y:-this.height*2,
		x:false
	}
	
	this.speed = this.getXY('speed');
	
	this.color = Settings.bullet.color;
	this.power = Settings.bullet.power;

	this.draw();
	
	
}
Bullet.prototype = Entity;


function Enemy(x,y)
{
	
	this.destroyOnOutOfScreen = false;
	
	this.type = 'enemy';
	this.targets = 'player';
	this.pos0 = {x:x, y:y};
	this.pos = {x:x, y: y - Settings.armada.height*canvas.height - Settings.armada.marginTop*canvas.height};
	
	this.moveto = {x:x, y:y};
	
	this.width = Settings.enemy.width;
	this.height = Settings.enemy.height;
	
	this.speed = this.getXY('speed');
	this.wave = this.getXY('wave');
	
	//this.wave = {
	//	x:Settings.armada.width * this.wave.x * canvas.width,
	//	y:Settings.armada.height * this.wave.y * canvas.height
	//}
	
	//console.log(this.wave);
	
	
	this.color = Settings.enemy.color;
	this.sprite = Settings.enemy.sprite;
	this.frame = 0;
	this.power = Settings.enemy.power;

	this.draw();
	
	this.getPosition = function()
	{
		
	}
	
}
Enemy.prototype = Entity;


function Explosion(x,y,width,height)
{
	
	this.type = 'explosion';
	
	this.destroyOnEndAnimation = true;
	
	this.width = width;
	this.height = height;
	this.pos = {x:x, y:y};
	
	
	this.moveto = {
		y:-this.height,
		x:false
	}
	
	this.speed = this.getXY('speed');
	
	this.sprite = Settings.explosion.sprite;
	this.frame = 0;
	
	
	this.draw();
	
	
}
Explosion.prototype = Entity;


function Player()
{
	
	this.type = 'player';
	
	//this.cantOutOfScreen = true;
	
	
	this.width = Settings.player.width;
	this.height = Settings.player.height;
	this.pos = {x:canvas.width/2, y:canvas.height - Settings.player.height - canvas.height*Settings.player.marginBottom};
	
	
	this.moveto = {
		y:false,
		x:false
	}
	
	this.speed = this.getXY('speed');
	
	this.color = Settings.player.color;
	this.sprite = Settings.player.sprite;
	this.frame = 0;
	this.power = Settings.player.power;
	
	this.draw();
	
	
}
Player.prototype = Entity;

function Star()
{
	
	this.type = 'star';
	
	this.destroyOnOutOfScreen = true;
	
	this.moveto = {
		x:false,
		y: canvas.height+1
	};
	//console.log(this.moveto);
	this.pos = {
		x:Math.floor((Math.random() * (canvas.width-1)) + 1),
		y:0
	};
	
	this.width = Settings.star.width;
	this.height = Settings.star.height;
	
	this.speed = this.getXY('speed');
	this.color = Settings.star.color;
	
	this.draw();
}
Star.prototype = Entity;

//# sourceMappingURL=main.min.js.map
